// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -D Default -D PartialEq -A -d -f config/crd/bases/runtime.cluster.x-k8s.io_extensionconfigs.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// DiscoverVariablesResponse is the response of the DiscoverVariables hook.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
#[kube(group = "runtime.cluster.x-k8s.io", version = "v1alpha1", kind = "ExtensionConfig", plural = "extensionconfigs")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ExtensionConfigSpec {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// message is a human-readable description of the status of the call.
    pub message: String,
    /// status of the call. One of "Success" or "Failure".
    pub status: String,
    /// variables are variable schemas for variables defined by the DiscoverVariables hook.
    pub variables: Vec<ExtensionConfigVariables>,
}

/// ClusterClassVariable defines a variable which can
/// be configured in the Cluster topology and used in patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariables {
    /// metadata is the metadata of a variable.
    /// It can be used to add additional data for higher level tools to
    /// a ClusterClassVariable.
    /// 
    /// Deprecated: This field is deprecated and is going to be removed in the next apiVersion. Please use XMetadata in JSONSchemaProps instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ExtensionConfigVariablesMetadata>,
    /// name of the variable.
    pub name: String,
    /// required specifies if the variable is required.
    /// Note: this applies to the variable as a whole and thus the
    /// top-level object defined in the schema. If nested fields are
    /// required, this will be specified inside the schema.
    pub required: bool,
    /// schema defines the schema of the variable.
    pub schema: ExtensionConfigVariablesSchema,
}

/// metadata is the metadata of a variable.
/// It can be used to add additional data for higher level tools to
/// a ClusterClassVariable.
/// 
/// Deprecated: This field is deprecated and is going to be removed in the next apiVersion. Please use XMetadata in JSONSchemaProps instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariablesMetadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// schema defines the schema of the variable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariablesSchema {
    /// openAPIV3Schema defines the schema of a variable via OpenAPI v3
    /// schema. The schema is a subset of the schema used in
    /// Kubernetes CRDs.
    #[serde(rename = "openAPIV3Schema")]
    pub open_apiv3_schema: ExtensionConfigVariablesSchemaOpenApiv3Schema,
}

/// openAPIV3Schema defines the schema of a variable via OpenAPI v3
/// schema. The schema is a subset of the schema used in
/// Kubernetes CRDs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariablesSchemaOpenApiv3Schema {
    /// additionalProperties specifies the schema of values in a map (keys are always strings).
    /// NOTE: Can only be set if type is object.
    /// NOTE: AdditionalProperties is mutually exclusive with Properties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalProperties")]
    pub additional_properties: Option<serde_json::Value>,
    /// allOf specifies that the variable must validate against all of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allOf")]
    pub all_of: Option<serde_json::Value>,
    /// anyOf specifies that the variable must validate against one or more of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "anyOf")]
    pub any_of: Option<serde_json::Value>,
    /// default is the default value of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// description is a human-readable description of this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// enum is the list of valid values of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enum")]
    pub r#enum: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// example is an example for this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub example: Option<serde_json::Value>,
    /// exclusiveMaximum specifies if the Maximum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMaximum")]
    pub exclusive_maximum: Option<bool>,
    /// exclusiveMinimum specifies if the Minimum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMinimum")]
    pub exclusive_minimum: Option<bool>,
    /// format is an OpenAPI v3 format string. Unknown formats are ignored.
    /// For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using)
    /// https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// items specifies fields of an array.
    /// NOTE: Can only be set if type is array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<serde_json::Value>,
    /// maxItems is the max length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxItems")]
    pub max_items: Option<i64>,
    /// maxLength is the max length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    pub max_length: Option<i64>,
    /// maxProperties is the maximum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxProperties")]
    pub max_properties: Option<i64>,
    /// maximum is the maximum of an integer or number variable.
    /// If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum.
    /// If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<i64>,
    /// minItems is the min length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minItems")]
    pub min_items: Option<i64>,
    /// minLength is the min length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    pub min_length: Option<i64>,
    /// minProperties is the minimum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minProperties")]
    pub min_properties: Option<i64>,
    /// minimum is the minimum of an integer or number variable.
    /// If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum.
    /// If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<i64>,
    /// not specifies that the variable must not validate against the subschema.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<serde_json::Value>,
    /// oneOf specifies that the variable must validate against exactly one of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneOf")]
    pub one_of: Option<serde_json::Value>,
    /// pattern is the regex which a string variable must match.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// properties specifies fields of an object.
    /// NOTE: Can only be set if type is object.
    /// NOTE: Properties is mutually exclusive with AdditionalProperties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    /// required specifies which fields of an object are required.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<String>>,
    /// type is the type of the variable.
    /// Valid values are: object, array, string, integer, number or boolean.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// uniqueItems specifies if items in an array must be unique.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uniqueItems")]
    pub unique_items: Option<bool>,
    /// x-kubernetes-int-or-string specifies that this value is
    /// either an integer or a string. If this is true, an empty
    /// type is allowed and type as child of anyOf is permitted
    /// if following one of the following patterns:
    /// 
    /// 1) anyOf:
    ///    - type: integer
    ///    - type: string
    /// 2) allOf:
    ///    - anyOf:
    ///      - type: integer
    ///      - type: string
    ///    - ... zero or more
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-int-or-string")]
    pub x_kubernetes_int_or_string: Option<bool>,
    /// x-kubernetes-preserve-unknown-fields allows setting fields in a variable object
    /// which are not defined in the variable schema. This affects fields recursively,
    /// except if nested properties or additionalProperties are specified in the schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-preserve-unknown-fields")]
    pub x_kubernetes_preserve_unknown_fields: Option<bool>,
    /// x-kubernetes-validations describes a list of validation rules written in the CEL expression language.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-validations")]
    pub x_kubernetes_validations: Option<Vec<ExtensionConfigVariablesSchemaOpenApiv3SchemaXKubernetesValidations>>,
    /// x-metadata is the metadata of a variable or a nested field within a variable.
    /// It can be used to add additional data for higher level tools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-metadata")]
    pub x_metadata: Option<ExtensionConfigVariablesSchemaOpenApiv3SchemaXMetadata>,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariablesSchemaOpenApiv3SchemaXKubernetesValidations {
    /// fieldPath represents the field path returned when the validation fails.
    /// It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field.
    /// e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo`
    /// If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList`
    /// It does not support list numeric index.
    /// It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](https://kubernetes.io/docs/reference/kubectl/jsonpath/) for more info.
    /// Numeric index of array is not supported.
    /// For field name which contains special characters, use `['specialName']` to refer the field name.
    /// e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// message represents the message displayed when validation fails. The message is required if the Rule contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a rule, then messageExpression will be used if validation
    /// fails. If messageExpression results in a runtime error, the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset.
    /// messageExpression has access to all the same variables as the rule; the only difference is the return type.
    /// Example:
    /// "x must be less than max ("+string(self.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule.
    /// The currently supported reasons are: "FieldValueInvalid", "FieldValueForbidden", "FieldValueRequired", "FieldValueDuplicate".
    /// If not set, default to use "FieldValueInvalid".
    /// All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<ExtensionConfigVariablesSchemaOpenApiv3SchemaXKubernetesValidationsReason>,
    /// rule represents the expression which will be evaluated by CEL.
    /// ref: https://github.com/google/cel-spec
    /// The Rule is scoped to the location of the x-kubernetes-validations extension in the schema.
    /// The `self` variable in the CEL expression is bound to the scoped value.
    /// If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable
    /// via `self.field` and field presence can be checked via `has(self.field)`.
    /// If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map
    /// are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map
    /// are accessible via CEL macros and functions such as `self.all(...)`.
    /// If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and
    /// functions.
    /// If the Rule is scoped to a scalar, `self` is bound to the scalar value.
    /// Examples:
    /// - Rule scoped to a map of objects: {"rule": "self.components['Widget'].priority < 10"}
    /// - Rule scoped to a list of integers: {"rule": "self.values.all(value, value >= 0 && value < 100)"}
    /// - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
    /// 
    /// Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL
    /// expressions. This includes:
    /// - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields.
    /// - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
    ///   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
    ///   - An array where the items schema is of an "unknown type"
    ///   - An object where the additionalProperties schema is of an "unknown type"
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ > 0"}
    ///   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop > 0"}
    ///   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d > 0"}
    /// 
    /// If `rule` makes use of the `oldSelf` variable it is implicitly a
    /// `transition rule`.
    /// 
    /// By default, the `oldSelf` variable is the same type as `self`.
    /// 
    /// Transition rules by default are applied only on UPDATE requests and are
    /// skipped if an old value could not be found.
    pub rule: String,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ExtensionConfigVariablesSchemaOpenApiv3SchemaXKubernetesValidationsReason {
    FieldValueInvalid,
    FieldValueForbidden,
    FieldValueRequired,
    FieldValueDuplicate,
}

/// x-metadata is the metadata of a variable or a nested field within a variable.
/// It can be used to add additional data for higher level tools.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ExtensionConfigVariablesSchemaOpenApiv3SchemaXMetadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

